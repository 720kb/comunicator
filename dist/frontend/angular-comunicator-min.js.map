{"version":3,"file":"angular-comunicator-min.js","sources":["../../lib/frontend/comunicator.js","../../lib/frontend/angular-comunicator.js"],"sourcesContent":["/*global window*/\nimport Rx from 'rxjs/Rx';\nimport WebSocket from 'ws';\nlet WebSocketCtor;\n\ntry {\n\n  WebSocketCtor = WebSocket;\n  if (!WebSocketCtor) {\n\n    WebSocketCtor = window.WebSocket;\n  }\n} catch (err) {\n\n  WebSocketCtor = window.WebSocket;\n}\n\nconst whoReallyAmISym = Symbol('whoReallyAmI')\n  , reallyTokenSym = Symbol('reallyToken')\n  , websocketSym = Symbol('websocket')\n  , queueSym = Symbol('queue')\n  , timeWaitSlice = 9000\n  , timeWaitSliceChoices = [0]\n  , giveMeATimeWait = () => {\n\n    return Math.floor(Math.random() * (timeWaitSliceChoices.length + 1));\n  };\n\nclass Comunicator extends Rx.Observable {\n  constructor(websocketUrl) {\n    if (!websocketUrl) {\n\n      throw new Error(`Mandatory parameter is missing: [websocketUrl] ${websocketUrl}`);\n    }\n\n    const internalObservable = new Rx.Observable(subscriber => {\n      let inError = false;\n\n      if (this[websocketSym] &&\n        (this[websocketSym].readyState !== WebSocketCtor.CONNECTING ||\n        this[websocketSym].readyState !== WebSocketCtor.OPEN)) {\n\n        inError = true;\n      }\n\n      if (typeof websocketUrl === 'string') {\n\n        this[websocketSym] = new WebSocketCtor(websocketUrl);\n      } else if (typeof websocketUrl === 'object' &&\n        websocketUrl instanceof WebSocketCtor) {\n\n        this[websocketSym] = websocketUrl;\n      } else {\n\n        throw new Error('websocket parameter passed is neither a string nor a WebSocket object');\n      }\n\n      this[websocketSym].onopen = event => {\n\n        subscriber.next({\n          'type': 'open',\n          'whoami': event.target\n        });\n\n        while (this[queueSym].length > 0 &&\n          this[websocketSym].readyState === WebSocketCtor.OPEN) {\n\n          this[websocketSym].push(this[queueSym].shift());\n        }\n      };\n\n      this[websocketSym].onmessage = event => {\n        const parsedMsg = JSON.parse(event.data);\n\n        if (parsedMsg.opcode === 'joined') {\n\n          subscriber.next({\n            'type': 'joined',\n            'whoami': parsedMsg.whoami\n          });\n        } else if (parsedMsg.opcode === 'to-me') {\n\n          subscriber.next({\n            'type': 'to-me',\n            'whoami': parsedMsg.whoami,\n            'who': parsedMsg.who,\n            'what': parsedMsg.what\n          });\n        } else if (parsedMsg.opcode === 'to-all') {\n\n          subscriber.next({\n            'type': 'to-all',\n            'whoami': parsedMsg.whoami,\n            'what': parsedMsg.what\n          });\n        }\n      };\n\n      this[websocketSym].onerror = error => {\n\n        subscriber.error({\n          'type': 'error',\n          'cause': error\n        });\n      };\n\n      this[websocketSym].onclose = () => {\n\n        subscriber.error({\n          'type': 'closed'\n        });\n      };\n\n      this[websocketSym].push = this[websocketSym].send;\n      this[websocketSym].send = (opcode, data) => {\n        const messageToSend = JSON.stringify({\n          opcode,\n          'token': this[reallyTokenSym],\n          data\n        });\n\n        if (this[websocketSym] &&\n          this[websocketSym].readyState === WebSocketCtor.OPEN) {\n\n          this[websocketSym].push(messageToSend);\n        } else {\n\n          this[queueSym].push(messageToSend);\n        }\n      };\n\n      if (inError &&\n        this[websocketSym].readyState !== WebSocketCtor.CONNECTING &&\n        this[websocketSym].readyState !== WebSocketCtor.OPEN) {\n\n        subscriber.error({\n          'type': 'closed'\n        });\n      }\n\n      return () => {\n\n        this[websocketSym].close();\n      };\n    }).share();\n\n    super(observer => {\n\n      const subscriptionToInternalObservable = internalObservable\n        .retryWhen(errors => errors.switchMap(() => {\n          const nextTimeWaitSliceChoice = timeWaitSlice * (Math.pow(2, timeWaitSliceChoices.length) - 1);\n\n          timeWaitSliceChoices.push(nextTimeWaitSliceChoice);\n          return Rx.Observable.timer(timeWaitSliceChoices[giveMeATimeWait()]);\n        }))\n        .subscribe(observer);\n\n      return () => {\n\n        subscriptionToInternalObservable.unsubscribe();\n      };\n    });\n\n    this[queueSym] = [];\n  }\n\n  userIsPresent(whoami, token) {\n\n    if (this[whoReallyAmISym] !== whoami ||\n      this[reallyTokenSym] !== token) {\n\n      if (whoami &&\n        token) {\n\n        this[whoReallyAmISym] = whoami;\n        this[reallyTokenSym] = token;\n\n        const joinMessage = JSON.stringify({\n          'opcode': 'join',\n          'whoami': this[whoReallyAmISym],\n          'token': this[reallyTokenSym]\n        });\n\n        if (this[websocketSym] &&\n          this[websocketSym].readyState === WebSocketCtor.OPEN) {\n\n          this[websocketSym].push(joinMessage);\n        } else {\n\n          this[queueSym].push(joinMessage);\n        }\n      } else {\n\n        throw new Error('User identification datas missing.');\n      }\n    } else {\n\n      throw new Error('User is already identified.');\n    }\n  }\n\n  sendTo(who, what, managed) {\n\n    if (this[whoReallyAmISym] &&\n      this[websocketSym]) {\n\n      const toSend = {\n        'whoami': this[whoReallyAmISym],\n        who,\n        what\n      };\n\n      if (managed) {\n\n        toSend.managed = true;\n      }\n\n      this[websocketSym].send('sendTo', toSend);\n    } else {\n\n      throw new Error('User identification required');\n    }\n  }\n\n  broadcast(what, managed) {\n\n    if (this[whoReallyAmISym] &&\n      this[websocketSym]) {\n\n      const toSend = {\n        'whoami': this[whoReallyAmISym],\n        'who': '*',\n        what\n      };\n\n      if (managed) {\n\n        toSend.managed = true;\n      }\n\n      this[websocketSym].send('broadcast', toSend);\n    } else {\n\n      throw new Error('User identification required');\n    }\n  }\n\n  get whoAmI() {\n\n    return this[whoReallyAmISym];\n  }\n}\n\nexport default Comunicator;\n","import angular from 'angular';\nimport Comunicator from './comunicator';\n\nangular.module('720kb.comunicator', [])\n.provider('Comunicator', () => {\n  let comunicator;\n  const initComunicator = url => {\n\n    comunicator = new Comunicator(url);\n    return comunicator;\n  };\n\n  return {\n    'setComunicatorServerURL': initComunicator,\n    '$get': /*@ngInject*/ () => {\n\n      return comunicator;\n    }\n  };\n});\n"],"names":["WebSocketCtor","WebSocket","window","err","whoReallyAmISym","Symbol","reallyTokenSym","websocketSym","queueSym","timeWaitSlice","timeWaitSliceChoices","giveMeATimeWait","Math","floor","random","length","Comunicator","websocketUrl","Error","internalObservable","Rx","Observable","inError","_this","readyState","CONNECTING","OPEN","onopen","next","event","target","push","shift","onmessage","parsedMsg","JSON","parse","data","opcode","whoami","who","what","onerror","error","onclose","send","messageToSend","stringify","close","share","subscriptionToInternalObservable","retryWhen","errors","switchMap","nextTimeWaitSliceChoice","pow","timer","subscribe","observer","unsubscribe","token","this","joinMessage","managed","toSend","angular","module","provider","comunicator","initComunicator","url"],"mappings":"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"}